
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>C3 P2P Tester</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<style>
  @keyframes p2pTapPulse {
    0%   { transform: scale(0.20); opacity: 0.95; }
    60%  { transform: scale(1.00); opacity: 0.35; }
    100% { transform: scale(1.28); opacity: 0.00; }
  }
  .p2p-tap-pulse { animation: p2pTapPulse 450ms ease-out forwards; }

  /* =========================
     Tester fullscreen + mobile viewport (svh) helpers
     Scoped to tester only via html/body class 'p2p-tester-mode'
     ========================= */
  :root { --app-height: 100vh; }

  .p2p-svh {
    height: var(--app-height);
    height: 100svh;
    min-height: var(--app-height);
    min-height: 100svh;
  }

  html.p2p-tester-mode,
  body.p2p-tester-mode {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    background: #000;
    overflow: hidden;
  }

  html.p2p-tester-mode:fullscreen,
  html.p2p-tester-mode:-webkit-full-screen {
    background: #000;
  }

  html.p2p-tester-mode:fullscreen::backdrop,
  html.p2p-tester-mode:-webkit-full-screen::backdrop {
    background: #000;
  }

</style>

</head>

<body class="bg-gray-900 text-white overflow-hidden">
<div id="root"></div>

<script type="text/babel">
  const { useState, useEffect, useRef, useMemo } = React;

  const ICE_SERVERS = [
    // Public STUN servers (no TURN)
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    { urls: 'stun:stun2.l.google.com:19302' },
    { urls: 'stun:global.stun.twilio.com:3478' }
  ];

  const PEER_OPTS = {
    debug: 1,
    // PeerJS Cloud (WSS/HTTPS) ‚Äî avoids ws:// quirks on iOS/in-app browsers
    host: '0.peerjs.com',
    port: 443,
    path: '/',
    secure: true,
    config: {
      iceServers: ICE_SERVERS,
      iceCandidatePoolSize: 4
    }
  };

  const createPeer = (id) => (id ? new Peer(id, PEER_OPTS) : new Peer(PEER_OPTS));

  const sleep = (ms) => new Promise(r => setTimeout(r, ms));
  const clamp01 = (v) => Math.max(0, Math.min(1, v));

  // =========================
  // ZIP chunk transfer helpers
  // =========================
  const CHUNK_SIZE = 128 * 1024;
  const BUFFER_HIGH_WATERMARK = 2 * 1024 * 1024;

  const makeChunkPacket = (chunkIndex, totalChunks, payloadU8) => {
    const out = new Uint8Array(8 + payloadU8.byteLength);
    const dv = new DataView(out.buffer, out.byteOffset, out.byteLength);
    dv.setUint32(0, chunkIndex);
    dv.setUint32(4, totalChunks);
    out.set(payloadU8, 8);
    return out;
  };

  const toArrayBuffer = async (data) => {
    if (!data) return null;
    if (data instanceof ArrayBuffer) return data;
    if (data instanceof Blob) return await data.arrayBuffer();
    if (ArrayBuffer.isView(data)) {
      return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
    }
    return null;
  };

  const parseChunkPacket = (ab) => {
    if (!(ab instanceof ArrayBuffer) || ab.byteLength < 8) return null;
    const dv = new DataView(ab);
    const chunkIndex = dv.getUint32(0);
    const totalChunks = dv.getUint32(4);
    const payload = ab.slice(8);
    return { chunkIndex, totalChunks, payload };
  };

  const waitDrain = async (conn) => {
    const dc = conn?._dc;
    if (!dc) return;
    while (dc.bufferedAmount > BUFFER_HIGH_WATERMARK) {
      await sleep(10);
    }
  };

  // =========================
  // WebRTC bitrate helper
  // =========================
  const setCallBitrate = async (call, {
    maxKbps = 8000,
    minKbps = 2000,
    maxFramerate = 60,
    scaleDown = 1.0
  } = {}) => {
    try {
      const pc = call?.peerConnection;
      if (!pc) return;
      const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
      if (!sender) return;

      const params = sender.getParameters();
      if (!params.encodings) params.encodings = [{}];

      params.encodings[0].maxBitrate = Math.floor(maxKbps * 1000);
      params.encodings[0].minBitrate = Math.floor(minKbps * 1000);
      params.encodings[0].maxFramerate = maxFramerate;
      params.encodings[0].scaleResolutionDownBy = scaleDown;

      await sender.setParameters(params);
    } catch (e) {
      console.warn('[RTC] setParameters failed', e);
    }
  };

  // =========================
  // Host overlay mapping helpers
  // =========================
  const computeContainedRect = (containerW, containerH, videoW, videoH) => {
    if (!containerW || !containerH || !videoW || !videoH) {
      return { x: 0, y: 0, w: containerW || 0, h: containerH || 0 };
    }
    const containerAR = containerW / containerH;
    const videoAR = videoW / videoH;

    if (videoAR > containerAR) {
      const w = containerW;
      const h = w / videoAR;
      const x = 0;
      const y = (containerH - h) / 2;
      return { x, y, w, h };
    } else {
      const h = containerH;
      const w = h * videoAR;
      const x = (containerW - w) / 2;
      const y = 0;
      return { x, y, w, h };
    }
  };

  // =========================
  // HOST (–ê–î–ú–ò–ù)
  // =========================
  const HostView = () => {
    const [peerId, setPeerId] = useState('');
    const [zipFile, setZipFile] = useState(null);
    const [statusMsg, setStatusMsg] = useState('Initializing...');
    const [remoteStream, setRemoteStream] = useState(null);
    const [isValidating, setIsValidating] = useState(false);

    const [logs, setLogs] = useState([]);
    const [cursor, setCursor] = useState({ visible: false, x: 0.5, y: 0.5, device: 'mouse' });
    const peerRef = useRef(null);
    const connRef = useRef(null);
    const videoRef = useRef(null);
    const zipFileRef = useRef(null);

    const consoleRef = useRef(null);
    const videoWrapRef = useRef(null);
    const [videoMeta, setVideoMeta] = useState({ vw: 0, vh: 0 });
    const [wrapSize, setWrapSize] = useState({ w: 0, h: 0 });

    const shouldAutoScrollRef = useRef(true);

    useEffect(() => {
      const id = Math.random().toString(36).substring(2, 10);
      const peer = createPeer(id);
      peerRef.current = peer;

      peer.on('error', (err) => {
        console.warn('[PeerJS] host error', err);
        const msg = (err && (err.type || err.name)) ? (err.type || err.name) : 'unknown';
        const details = err && err.message ? `: ${err.message}` : '';
        setStatusMsg(`Peer error (${msg})${details}`);
      });

      peer.on('disconnected', () => {
        try { peer.reconnect(); } catch (e) {}
      });

      peer.on('open', (id) => {
        setPeerId(id);
        setStatusMsg('Ready. Select ZIP.');
      });

      peer.on('connection', (conn) => {
        connRef.current = conn;

        const connectWatchdog = setTimeout(() => {
          if (!conn.open) {
            setStatusMsg('Still connecting... Tip: on iPhone open in Safari and try Wi‚ÄëFi. Without TURN some networks cannot do P2P.');
          }
        }, 8000);

        try { conn.binaryType = 'arraybuffer'; } catch (e) {}

        setStatusMsg('Tester connected!');

        conn.on('open', async () => {
          try { conn.binaryType = 'arraybuffer'; } catch (e) {}

          conn.on('data', (data) => {
            if (!data || typeof data !== 'object') return;

            if (data.type === 'log_batch' && Array.isArray(data.entries)) {
              setLogs(prev => {
                const next = prev.concat(
                  data.entries.map((e) => ({
                    id: e.id || (crypto?.randomUUID?.() || String(Math.random())),
                    level: e.level || 'log',
                    ts: e.ts || Date.now(),
                    t: e.t || 0,
                    text: e.text || '',
                  }))
                );
                return next.length > 2000 ? next.slice(next.length - 2000) : next;
              });
              return;
            }

            if (data.type === 'input' && data.payload) {
              const p = data.payload;

              if (p.kind === 'cursor') {
                setCursor({
                  visible: !!p.visible,
                  x: clamp01(p.x ?? 0.5),
                  y: clamp01(p.y ?? 0.5),
                  device: p.device || 'mouse',
                });
                return;
              }
            }
          });

          const file = zipFileRef.current;
          if (file) await sendFile(conn, file);
          else setStatusMsg('Tester connected. Upload ZIP.');
        });

        conn.on('close', () => {
          setStatusMsg('Tester disconnected.');
          setRemoteStream(null);
          setCursor({ visible: false, x: 0.5, y: 0.5, device: 'mouse' });
        });
      });

      peer.on('call', (call) => {
        call.answer(null);
        call.on('error', (err) => console.warn('[PeerJS] media error', err));
        call.on('close', () => setRemoteStream(null));
        call.on('stream', (stream) => {
          // Grab dimensions early (helps correct letterboxing before <video> metadata updates)
          try {
            const vt = stream?.getVideoTracks?.()[0];
            const s = vt?.getSettings?.() || {};
            if (s.width && s.height) setVideoMeta({ vw: s.width, vh: s.height });
          } catch (e) {}
          setRemoteStream(stream);
          setStatusMsg('Receiving stream...');
        });
      });

      return () => {
        try { peer.destroy(); } catch (e) {}
        peerRef.current = null;
        connRef.current = null;
      };
    }, []);

    useEffect(() => {
      if (videoRef.current && remoteStream) {
        videoRef.current.srcObject = remoteStream;
      }
    }, [remoteStream]);

    useEffect(() => {
      const v = videoRef.current;
      if (!v) return;
      const onMeta = () => setVideoMeta({ vw: v.videoWidth || 0, vh: v.videoHeight || 0 });
      v.addEventListener('loadedmetadata', onMeta);
      v.addEventListener('resize', onMeta);
      return () => {
        v.removeEventListener('loadedmetadata', onMeta);
        v.removeEventListener('resize', onMeta);
      };
    }, []);

    useEffect(() => {
      const el = videoWrapRef.current;
      if (!el) return;

      const ro = new ResizeObserver(() => {
        const rect = el.getBoundingClientRect();
        setWrapSize({ w: rect.width, h: rect.height });
      });
      ro.observe(el);
      const rect = el.getBoundingClientRect();
      setWrapSize({ w: rect.width, h: rect.height });
      return () => ro.disconnect();
    }, []);

    const contentRect = useMemo(() => {
      return computeContainedRect(wrapSize.w, wrapSize.h, videoMeta.vw, videoMeta.vh);
    }, [wrapSize, videoMeta]);

    const cursorStyle = useMemo(() => {
      const px = contentRect.x + cursor.x * contentRect.w;
      const py = contentRect.y + cursor.y * contentRect.h;
      return { transform: `translate(${px}px, ${py}px) translate(-50%, -50%)` };
    }, [cursor, contentRect]);
    const handleFile = async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;

      setIsValidating(true);
      try {
        const zip = await JSZip.loadAsync(file);
        const hasIndex = Object.keys(zip.files).some(p => p.toLowerCase().endsWith('index.html'));
        if (!hasIndex) {
          alert('No index.html found!');
          setIsValidating(false);
          return;
        }

        setZipFile(file);
        zipFileRef.current = file;
        setStatusMsg('Verified! Share link.');

        if (connRef.current && connRef.current.open) {
          await sendFile(connRef.current, file);
        }
      } catch (err) {
        console.error(err);
        alert('Invalid ZIP');
      }
      setIsValidating(false);
    };

    const sendFile = async (conn, file) => {
      if (!conn || !conn.open || !file) return;

      setStatusMsg(`Sending ${file.name}...`);

      const buffer = await file.arrayBuffer();
      const u8 = new Uint8Array(buffer);
      const totalChunks = Math.ceil(u8.byteLength / CHUNK_SIZE);

      conn.send({
        type: 'meta',
        filename: file.name,
        size: u8.byteLength,
        chunkSize: CHUNK_SIZE,
        totalChunks
      });

      await sleep(150);

      for (let i = 0; i < totalChunks; i++) {
        const start = i * CHUNK_SIZE;
        const end = Math.min(u8.byteLength, start + CHUNK_SIZE);
        const payload = u8.slice(start, end);
        const packetU8 = makeChunkPacket(i, totalChunks, payload);

        await waitDrain(conn);
        conn.send(packetU8);

        if (i % 32 === 0) await sleep(0);
      }

      await sleep(50);
      conn.send({ type: 'done' });
      setStatusMsg('Sent. Waiting for stream...');
    };

    const link = peerId
      ? `${window.location.origin}${window.location.pathname}#/play?host=${peerId}`
      : '...';

    useEffect(() => {
      const el = consoleRef.current;
      if (!el) return;
      if (shouldAutoScrollRef.current) el.scrollTop = el.scrollHeight;
    }, [logs.length]);

    const onConsoleScroll = () => {
      const el = consoleRef.current;
      if (!el) return;
      const dist = el.scrollHeight - el.scrollTop - el.clientHeight;
      shouldAutoScrollRef.current = dist < 60;
    };

    const clearLogs = () => setLogs([]);

    return (
      <div className="w-screen h-screen p-0 m-0">
        <div className="w-full h-full flex gap-0">
          {/* LEFT */}
          <div className="flex-1 h-full flex flex-col min-w-0">
            {/* top bar */}
            <div className="bg-gray-800 p-3 border-b border-gray-700 flex items-center gap-4">
              <label className="flex-1 max-w-xs block px-3 py-2 border-2 border-dashed border-gray-600 rounded-lg text-center cursor-pointer hover:border-blue-500">
                <input type="file" onChange={handleFile} className="hidden" accept=".zip" />
                <div className="text-2xl mb-1">
                  {zipFile ? '‚úÖ' : (isValidating ? '‚è≥' : 'üìÇ')}
                </div>
                <span className="text-xs truncate block">
                  {zipFile ? zipFile.name : "Select Game ZIP"}
                </span>
              </label>

              <div className="flex-1 flex flex-col gap-1 min-w-0">
                <div className="flex gap-2">
                  <input
                    readOnly
                    value={zipFile ? link : '...'}
                    className="bg-black/50 border border-gray-600 rounded px-2 py-1 w-full text-xs"
                  />
                  <button
                    onClick={() => zipFile && navigator.clipboard.writeText(link)}
                    className="bg-blue-600 px-3 py-1 rounded text-sm"
                  >
                    üìã
                  </button>
                </div>
                <div className="text-xs text-gray-400">{statusMsg}</div>
              </div>
            </div>

            {/* video fills remaining space */}
            <div className="flex-1 p-3">
              <div
                ref={videoWrapRef}
                className="w-full h-full bg-black rounded-xl border border-gray-700 overflow-hidden relative"
              >
                {remoteStream ? (
                  <>
                    <video
                      ref={videoRef}
                      className="absolute"
                      autoPlay
                      playsInline
                      style={{
                        left: contentRect.x,
                        top: contentRect.y,
                        width: contentRect.w,
                        height: contentRect.h,
                        objectFit: 'contain'
                      }}
                    />

                    {/* cursor */}
                    {cursor.visible && (
                      <div
                        className="absolute w-4 h-4 rounded-full border border-white/80 bg-white/20 pointer-events-none"
                        style={cursorStyle}
                      />
                    )}
                  </>
                ) : (
                  <div className="w-full h-full flex items-center justify-center text-gray-500 text-center text-sm">
                    <div>
                      <div className="text-4xl mb-2">üì∫</div>
                      Waiting for stream...
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>

          {/* RIGHT console */}
          <div className="w-[420px] max-w-[45vw] min-w-[320px] h-full flex flex-col bg-gray-800 border-l border-gray-700">
            <div className="flex items-center justify-between px-3 py-2 border-b border-gray-700">
              <div className="text-sm font-semibold text-gray-200">Console</div>
              <button
                onClick={clearLogs}
                className="text-xs bg-gray-900/60 hover:bg-gray-900 border border-gray-700 rounded px-2 py-1"
              >
                Clear
              </button>
            </div>

            <div
              ref={consoleRef}
              onScroll={onConsoleScroll}
              className="flex-1 overflow-auto p-2 text-xs leading-4"
            >
              {logs.length === 0 ? (
                <div className="text-gray-400 p-2">No logs yet.</div>
              ) : (
                logs.map((l, idx) => {
                  const bg = idx % 2 === 0 ? 'bg-black/25' : 'bg-black/10';
                  const levelColor =
                    l.level === 'error' ? 'text-red-300' :
                    l.level === 'warn' ? 'text-yellow-300' :
                    l.level === 'info' ? 'text-blue-300' :
                    'text-gray-200';

                  const full = String(l.text || '');
                  const isLong = full.length > 140 || full.includes('\n');
                  const summary = isLong ? (full.slice(0, 140) + '‚Ä¶') : full;

                  const time = new Date(l.ts || Date.now()).toLocaleTimeString();

                  return (
                    <div key={l.id} className={`rounded mb-1 ${bg} border border-white/5`}>
                      <details>
                        <summary className="cursor-pointer select-none px-2 py-1 flex gap-2 items-start">
                          <span className="text-gray-400 shrink-0">{time}</span>
                          <span className={`shrink-0 uppercase ${levelColor}`}>{l.level}</span>
                          <span className="text-gray-100 break-words">
                            {summary || <span className="text-gray-500">(empty)</span>}
                          </span>
                        </summary>
                        <div className="px-2 pb-2 text-gray-200">
                          <pre className="whitespace-pre-wrap break-words">{full}</pre>
                        </div>
                      </details>
                    </div>
                  );
                })
              )}
            </div>

            <div className="px-3 py-2 border-t border-gray-700 text-[11px] text-gray-400">
              Logs are forwarded from tester (batched every 200ms).
            </div>
          </div>
        </div>
      </div>
    );
  };

  // =========================
  // TESTER (–ò–ì–†–û–ö)
  // =========================
  const TesterView = ({ hostId }) => {
    const [msg, setMsg] = useState('Connecting...');
    const [isReady, setIsReady] = useState(false);

    const peerRef = useRef(null);
    const iframeRef = useRef(null);
    const callRef = useRef(null);
    const connRef = useRef(null);

    const recvMetaRef = useRef(null);
    const recvChunksRef = useRef(null);
    const recvCountRef = useRef(0);

    // logs batching
    const logQueueRef = useRef([]);
    const logSeqRef = useRef(0);
    const flushTimerRef = useRef(null);

    // input throttling
    const lastCursorSendRef = useRef(0);

    useEffect(() => {
      // === Tester-only viewport + fullscreen helpers (Poki/CrazyGames-like) ===
      const prevViewportMeta = document.querySelector('meta[name="viewport"]')?.getAttribute('content') || null;
      const setViewportMeta = () => {
        const meta = document.querySelector('meta[name="viewport"]');
        if (!meta) return;
        // viewport-fit=cover helps on iOS notch devices; no visual change on desktop
        const base = 'width=device-width, initial-scale=1.0, viewport-fit=cover';
        meta.setAttribute('content', base);
      };

      const applyTesterMode = () => {
        document.documentElement.classList.add('p2p-tester-mode');
        document.body.classList.add('p2p-tester-mode');
        setViewportMeta();
      };

      const removeTesterMode = () => {
        document.documentElement.classList.remove('p2p-tester-mode');
        document.body.classList.remove('p2p-tester-mode');
        const meta = document.querySelector('meta[name="viewport"]');
        if (meta && prevViewportMeta) meta.setAttribute('content', prevViewportMeta);
      };

      const updateAppHeight = () => {
        const h = window.visualViewport?.height || window.innerHeight || 0;
        if (h) document.documentElement.style.setProperty('--app-height', `${h}px`);
      };

      applyTesterMode();
      updateAppHeight();

      const vv = window.visualViewport;
      const onResize = () => updateAppHeight();
      window.addEventListener('resize', onResize, { passive: true });
      window.addEventListener('orientationchange', onResize, { passive: true });
      vv && vv.addEventListener('resize', onResize, { passive: true });


      if (!window.RTCPeerConnection) {
        setMsg('WebRTC is not supported in this browser. Please open the link in Safari.');
        return;
      }
      const peer = createPeer();
      peerRef.current = peer;

      // iOS / in-app browsers: surface failures instead of staying on "Connecting..."
      const peerOpenWatchdog = setTimeout(() => {
        setMsg('Connecting... If you are on iPhone: open this link in Safari (not in-app browser). Try Wi‚ÄëFi (some networks block P2P without TURN).');
      }, 7000);

      peer.on('error', (err) => {
        console.warn('[PeerJS] tester error', err);
        const msg = (err && (err.type || err.name)) ? (err.type || err.name) : 'unknown';
        const details = err && err.message ? `: ${err.message}` : '';
        setMsg(`Connection error (${msg})${details}`);
      });

      peer.on('disconnected', () => {
        try { peer.reconnect(); } catch (e) {}
      });

      peer.on('open', () => {
        clearTimeout(peerOpenWatchdog);

        const conn = peer.connect(hostId, { reliable: true, serialization: 'binary' });
        connRef.current = conn;
        try { conn.binaryType = 'arraybuffer'; } catch (e) {}

        const connectWatchdog = setTimeout(() => {
          if (!conn.open) {
            setMsg('Connecting... If you are on iPhone: open this link in Safari (not in-app browser). Try Wi‚ÄëFi (some networks block P2P without TURN).');
          }
        }, 8000);

        conn.on('open', () => {
          clearTimeout(connectWatchdog);
          try { conn.binaryType = 'arraybuffer'; } catch (e) {}
          setMsg('Connected! Waiting for data...');
        });

        conn.on('data', async (data) => {
          if (data && typeof data === 'object' && data.type === 'meta') {
            recvMetaRef.current = data;
            recvChunksRef.current = new Array(data.totalChunks);
            recvCountRef.current = 0;
            setMsg('Downloading game...');
            return;
          }

          if (data && typeof data === 'object' && data.type === 'done') {
            await tryAssembleAndProcess();
            return;
          }

          const ab = await toArrayBuffer(data);
          if (!ab) return;

          const parsed = parseChunkPacket(ab);
          if (!parsed) return;

          const meta = recvMetaRef.current;
          if (!meta || meta.totalChunks !== parsed.totalChunks) return;

          const chunks = recvChunksRef.current;
          if (!chunks) return;

          const { chunkIndex, payload } = parsed;
          if (chunkIndex < 0 || chunkIndex >= meta.totalChunks) return;

          if (!chunks[chunkIndex]) {
            chunks[chunkIndex] = payload;
            recvCountRef.current += 1;
          }
        });

        conn.on('error', (err) => {
          clearTimeout(connectWatchdog);
          console.warn('[PeerJS] data error', err);
          const msg = (err && (err.type || err.name)) ? (err.type || err.name) : 'unknown';
          const details = err && err.message ? `: ${err.message}` : '';
          setMsg(`Connection error (${msg})${details}`);
        });

        conn.on('close', () => {
          clearTimeout(connectWatchdog);
          setMsg('Host disconnected');
        });
      });

      return () => {
        try {
          window.removeEventListener('resize', onResize);
          window.removeEventListener('orientationchange', onResize);
          vv && vv.removeEventListener('resize', onResize);
        } catch (e) {}
        removeTesterMode();

        clearTimeout(peerOpenWatchdog);
        try { peer.destroy(); } catch (e) {}
        peerRef.current = null;
        connRef.current = null;
      };
    }, [hostId]);

    const enqueueLog = (entry) => {
      logQueueRef.current.push(entry);
      if (!flushTimerRef.current) {
        flushTimerRef.current = setInterval(() => flushLogs(), 200);
      }
    };

    const flushLogs = () => {
      const conn = connRef.current;
      if (!conn || !conn.open) return;

      const q = logQueueRef.current;
      if (!q.length) return;

      const batch = q.splice(0, 200);
      conn.send({ type: 'log_batch', entries: batch });

      if (!logQueueRef.current.length) {
        clearInterval(flushTimerRef.current);
        flushTimerRef.current = null;
      }
    };

    const sendInput = (payload) => {
      const conn = connRef.current;
      if (!conn || !conn.open) return;
      conn.send({ type: 'input', payload });
    };

    const tryAssembleAndProcess = async () => {
      const meta = recvMetaRef.current;
      const chunks = recvChunksRef.current;
      if (!meta || !chunks) {
        setMsg('Error: missing data');
        return;
      }

      for (let attempt = 0; attempt < 10; attempt++) {
        if (recvCountRef.current === meta.totalChunks) break;
        await sleep(120);
      }

      if (recvCountRef.current !== meta.totalChunks) {
        setMsg('Error: missing chunk(s)');
        return;
      }

      const parts = [];
      for (let i = 0; i < meta.totalChunks; i++) {
        if (!chunks[i]) {
          setMsg('Error: missing chunk(s)');
          return;
        }
        parts.push(new Uint8Array(chunks[i]));
      }

      const size = parts.reduce((s, b) => s + b.byteLength, 0);
      const out = new Uint8Array(size);
      let offset = 0;
      for (const b of parts) {
        out.set(b, offset);
        offset += b.byteLength;
      }

      await processZip(out.buffer);
    };

    const processZip = async (zipArrayBuffer) => {
      try {
        const zip = await JSZip.loadAsync(zipArrayBuffer);
        const files = [];
        let hasIndex = false;

        const patchIntoIndex = async (blob) => {
          let text = await blob.text();

          // Patch:
          // - Safe internal SW register
          // - WebGL tweaks
          // - Console forwarder
          // - Soft fullscreen (no forced orientation, uses body, re-enters on next tap)
          const patch = `
<script>
(function() {
  // --- Safe internal SW register block ---
  try {
    if (navigator.serviceWorker && navigator.serviceWorker.register) {
      const orig = navigator.serviceWorker.register.bind(navigator.serviceWorker);
      navigator.serviceWorker.register = function(scriptURL, options) {
        try {
          const u = String(scriptURL || '');
          if (u.includes('sw.js') || u.includes('service-worker') || u.includes('offline')) {
            return Promise.resolve({ scope: (options && options.scope) || '' });
          }
        } catch(e) {}
        return orig(scriptURL, options);
      };
    }
  } catch(e) {}

  // --- WebGL tweaks ---
  try {
    const oldGetContext = HTMLCanvasElement.prototype.getContext;
    HTMLCanvasElement.prototype.getContext = function(type, options) {
      options = options || {};
      if (type === 'webgl' || type === 'webgl2') {
        options.preserveDrawingBuffer = true;
        options.alpha = false;
        options.stencil = true;
      }
      return oldGetContext.call(this, type, options);
    };
  } catch(e) {}

  // --- Console forwarder ---
  try {
    const send = function(level, args) {
      try {
        const payload = {
          __p2p_log__: true,
          level: level,
          ts: Date.now(),
          t: (performance && performance.now) ? performance.now() : 0,
          args: args
        };
        window.parent && window.parent.postMessage(payload, '*');
      } catch(e) {}
    };

    const wrap = function(level, orig) {
      return function() {
        try {
          const arr = Array.prototype.slice.call(arguments).map(function(v) {
            try {
              if (v instanceof Error) return (v.name + ': ' + v.message + '\\n' + (v.stack || ''));
              if (typeof v === 'string') return v;
              return JSON.stringify(v);
            } catch(e) {
              try { return String(v); } catch(e2) { return '[unserializable]'; }
            }
          });
          send(level, arr);
        } catch(e) {}
        return orig && orig.apply(console, arguments);
      };
    };

    console.log = wrap('log', console.log);
    console.info = wrap('info', console.info);
    console.warn = wrap('warn', console.warn);
    console.error = wrap('error', console.error);

    window.addEventListener('error', function(ev) {
      try {
        send('error', [String(ev.message || 'Error'), String(ev.filename || ''), String(ev.lineno || ''), String(ev.colno || ''), ev.error ? (ev.error.stack || String(ev.error)) : '' ]);
      } catch(e) {}
    });

    window.addEventListener('unhandledrejection', function(ev) {
      try {
        const r = ev && ev.reason;
        let msg = '';
        try {
          msg = (r && r.stack) ? r.stack : (typeof r === 'string' ? r : JSON.stringify(r));
        } catch(e) { try { msg = String(r); } catch(e2) { msg = '[unserializable rejection]'; } }
        
        // Suppress noisy Construct / browser permission check rejections
        try {
          const low = String(msg || '').toLowerCase();
          if (low.includes('permissions check failed')) {
            try { ev && ev.preventDefault && ev.preventDefault(); } catch(e) {}
            return;
          }
        } catch(e) {}
        send('error', ['UnhandledRejection', msg]);
      } catch(e) {}
    });
  } catch(e) {}

  // --- Block game-driven fullscreen + forced orientation (Construct sometimes toggles/rotates on extra taps) ---
  // We control fullscreen from the outer wrapper. Inside the iframe we only want gameplay taps.
  try {
    // 1) Block requestFullscreen calls from inside the game (avoid Construct toggling/rotating fallback)
    const blockFS = function() { return Promise.resolve(); };

    try {
      const proto = (window.HTMLElement && window.HTMLElement.prototype) || (window.Element && window.Element.prototype);
      if (proto) {
        if (proto.requestFullscreen) proto.requestFullscreen = blockFS;
        if (proto.webkitRequestFullscreen) proto.webkitRequestFullscreen = blockFS;
        if (proto.webkitEnterFullscreen) proto.webkitEnterFullscreen = blockFS;
      }
    } catch(e) {}

    try {
      if (document.exitFullscreen) document.exitFullscreen = () => Promise.resolve();
      if (document.webkitExitFullscreen) document.webkitExitFullscreen = () => Promise.resolve();
    } catch(e) {}

    // 2) Block orientation locks to a specific axis. Allow only "any"/"natural".
    try {
      const so = screen && screen.orientation;
      if (so && so.lock) {
        const origLock = so.lock.bind(so);
        so.lock = function(mode) {
          try {
            const m = String(mode || '').toLowerCase();
            if (!m || m === 'any' || m === 'natural') {
              return origLock(mode).catch(() => Promise.resolve());
            }
            // swallow "portrait"/"landscape" locks
            return Promise.resolve();
          } catch(e) { return Promise.resolve(); }
        };
      }
    } catch(e) {}

    // Legacy APIs
    try { if (screen && screen.lockOrientation) screen.lockOrientation = () => true; } catch(e) {}
    try { if (screen && screen.unlockOrientation) screen.unlockOrientation = () => true; } catch(e) {}
  } catch(e) {}


  } catch(e) {}
})();
<\/script>`;

          if (text.includes('<head>')) text = text.replace('<head>', '<head>' + patch);
          else text = patch + text;

          return new Blob([text], { type: 'text/html' });
        };

        const promises = Object.keys(zip.files).map(async (path) => {
          const entry = zip.files[path];
          if (entry.dir) return;

          let blob = await entry.async('blob');

          if (path.toLowerCase().endsWith('index.html')) {
            blob = await patchIntoIndex(blob);
            hasIndex = true;
          }

          files.push({ path, blob });
        });

        await Promise.all(promises);

        if (!hasIndex) { setMsg('Error: No index.html'); return; }
        if (!('serviceWorker' in navigator)) { setMsg('Service Worker not supported'); return; }

        const reg = await navigator.serviceWorker.register('./worker.js');
        await reg.update();

        const waitForController = () => {
          if (navigator.serviceWorker.controller) return Promise.resolve();
          return new Promise(resolve => {
            navigator.serviceWorker.addEventListener('controllerchange', () => resolve(), { once: true });
          });
        };

        setMsg('Activating Environment...');
        await waitForController();

        const onMessage = (e) => {
          if (e.data && e.data.type === 'CACHE_COMPLETE') {
            setIsReady(true);
            setMsg('');
            navigator.serviceWorker.removeEventListener('message', onMessage);
          }
        };
        navigator.serviceWorker.addEventListener('message', onMessage);

        navigator.serviceWorker.controller.postMessage({ type: 'CACHE_FILES', files });
      } catch (e) {
        console.error(e);
        setMsg('Error processing file.');
      }
    };

    const placeCallWithBitrate = async (stream) => {
      try {
        const vt = stream.getVideoTracks?.()[0];
        if (vt) vt.contentHint = 'detail';
      } catch (e) {}

      const call = peerRef.current.call(hostId, stream);
      callRef.current = call;

      setTimeout(() => {
        setCallBitrate(call, { maxKbps: 8000, minKbps: 2000, maxFramerate: 60, scaleDown: 1.0 });
      }, 250);
    };

    const startStreaming = async () => {
      if (!peerRef.current) return;

      // 1) Prefer canvas.captureStream (no screen-share prompt).
      //    Retry a bit: many games create the <canvas> shortly after iframe load.
      try {
        for (let i = 0; i < 40; i++) { // ~8s
          const iframe = iframeRef.current;
          const doc = iframe?.contentDocument || iframe?.contentWindow?.document;
          const canvas = doc ? doc.querySelector('canvas') : null;

          if (canvas && canvas.captureStream) {
            const stream = canvas.captureStream(60);
            await placeCallWithBitrate(stream);
            return;
          }
          await sleep(200);
        }
      } catch (e) {}

      // 2) Fallback (desktop): ask user to share tab/screen
      if (navigator.mediaDevices?.getDisplayMedia) {
        try {
          const stream = await navigator.mediaDevices.getDisplayMedia({
            video: { frameRate: 60, width: { ideal: 1920 }, height: { ideal: 1080 } },
            audio: true
          });

          const vt = stream.getVideoTracks()[0];
          if (vt) vt.addEventListener('ended', () => callRef.current && callRef.current.close());

          await placeCallWithBitrate(stream);
          return;
        } catch (e) {
          console.warn('[Stream] getDisplayMedia failed', e);
        }
      }

      // 3) No supported capture method (common in iOS in-app browsers)
      console.warn('[Stream] No capture method available (need canvas.captureStream or getDisplayMedia).');
    };

    // Receive logs from iframe via postMessage
    useEffect(() => {
      const onMsg = (ev) => {
        const d = ev.data;
        if (!d || !d.__p2p_log__) return;

        const level = d.level || 'log';
        const ts = d.ts || Date.now();
        const t = d.t || 0;
        const args = Array.isArray(d.args) ? d.args : [String(d.args ?? '')];
        const text = args.join(' ');

        const id = `${Date.now()}_${logSeqRef.current++}`;
        enqueueLog({ id, level, ts, t, text });
      };

      window.addEventListener('message', onMsg);
      return () => window.removeEventListener('message', onMsg);
    }, []);

    // ‚úÖ Input forwarding FIX (correct coordinates)
    const cleanupInputRef = useRef(null);

    const attachInputListenersInsideIframe = () => {
      const iframe = iframeRef.current;
      if (!iframe) return null;

      const win = iframe.contentWindow;
      const doc = iframe.contentDocument || win?.document;
      if (!win || !doc) return null;

      const norm = (clientX, clientY) => {
        const w = win.innerWidth || 1;
        const h = win.innerHeight || 1;
        return { x: clamp01(clientX / w), y: clamp01(clientY / h) };
      };

      const sendCursor = (clientX, clientY, device = 'mouse') => {
        const now = performance.now();
        if (now - lastCursorSendRef.current < 16) return; // ~60fps
        lastCursorSendRef.current = now;
        const { x, y } = norm(clientX, clientY);
        sendInput({ kind: 'cursor', visible: true, x, y, device });
      };

      const hideCursor = () => {
        sendInput({ kind: 'cursor', visible: false, x: 0.5, y: 0.5, device: 'mouse' });
      };

      const hasPointer = !!win.PointerEvent;

      const onPointerMove = (e) => {
        if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
          sendCursor(e.clientX, e.clientY, e.pointerType);
        } else {
          // Touch: do not show cursor at all
          hideCursor();
        }
      };

      const onPointerDown = (e) => {
        if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
          sendCursor(e.clientX, e.clientY, e.pointerType);
        } else {
          hideCursor();
        }
      };

      const onMouseMove = (e) => sendCursor(e.clientX, e.clientY, 'mouse');

      // capture=true to catch even if game stops propagation
      if (hasPointer) {
        doc.addEventListener('pointermove', onPointerMove, { passive: true, capture: true });
        doc.addEventListener('pointerdown', onPointerDown, { passive: true, capture: true });
      } else {
        doc.addEventListener('mousemove', onMouseMove, { passive: true, capture: true });
      }

      win.addEventListener('blur', hideCursor, { passive: true });

      return () => {
        if (hasPointer) {
          doc.removeEventListener('pointermove', onPointerMove, true);
          doc.removeEventListener('pointerdown', onPointerDown, true);
        } else {
          doc.removeEventListener('mousemove', onMouseMove, true);
        }
        win.removeEventListener('blur', hideCursor);
      };
    };

    const handleGameLoaded = () => {
      // attach inputs
      if (cleanupInputRef.current) {
        try { cleanupInputRef.current(); } catch (e) {}
        cleanupInputRef.current = null;
      }
      cleanupInputRef.current = attachInputListenersInsideIframe();

      // Inject CSS + fullscreen behavior inside the game iframe (same-origin only)
      try {
        const iframe = iframeRef.current;
        const win = iframe?.contentWindow;
        const doc = iframe?.contentDocument || win?.document;
        if (doc) {
          // Style: fill visible area (svh), remove margins, black background
          const style = doc.createElement('style');
          style.textContent = `
            html, body {
              margin: 0 !important;
              padding: 0 !important;
              width: 100% !important;
              height: 100% !important;
              background: #000 !important;
              overflow: hidden !important;
              touch-action: manipulation !important;
            }
            @supports (height: 100svh) {
              html, body { height: 100svh !important; }
            }
            canvas, #c2canvas, .c3canvas {
              width: 100% !important;
              height: 100% !important;
              display: block !important;
              background: #000 !important;
              object-fit: cover !important; /* no letterboxing; may crop depending on game */
            }
          `;
          doc.head && doc.head.appendChild(style);

          // Fullscreen: request on TOP document root, not on iframe/canvas.
          const script = doc.createElement('script');
          script.textContent = `
            (function(){
              function isFullscreen(d){
                return !!(d.fullscreenElement || d.webkitFullscreenElement);
              }
              function requestSafeFullscreen(){
                try {
                  var topWin = window.top;
                  var topDoc = topWin && topWin.document;
                  if (topDoc && isFullscreen(topDoc)) return;
                  if (isFullscreen(document)) return;

                  // Best effort: scroll a tiny bit to encourage UI collapse on mobile
                  try { (topWin || window).scrollTo(0, 1); } catch(e){}

                  var el = (topDoc && (topDoc.documentElement || topDoc.body)) || (document.documentElement || document.body);
                  var fn = el.requestFullscreen || el.webkitRequestFullscreen;
                  if (fn) fn.call(el);

                  // Do NOT lock orientation. User controls it by rotating device.
                  // If browser supports it and wants stabilization, allow any/natural (ignored if unsupported)
                  try {
                    var so = (topWin && topWin.screen && topWin.screen.orientation) || (screen && screen.orientation);
                    if (so && so.lock) { so.lock('any').catch(function(){}); }
                  } catch(e){}
                } catch(e){}
              }

              // Must be called from a user gesture
              document.addEventListener('pointerdown', requestSafeFullscreen, {passive:true, capture:true});
              document.addEventListener('touchend', requestSafeFullscreen, {passive:true, capture:true});
              document.addEventListener('click', requestSafeFullscreen, {passive:true, capture:true});
            })();
          `;
          doc.documentElement.appendChild(script);
        }
      } catch (e) {}


      // start stream
      setTimeout(() => startStreaming(), 400);
    };

    useEffect(() => {
      return () => {
        if (cleanupInputRef.current) {
          try { cleanupInputRef.current(); } catch (e) {}
          cleanupInputRef.current = null;
        }
        if (flushTimerRef.current) {
          clearInterval(flushTimerRef.current);
          flushTimerRef.current = null;
        }
      };
    }, []);

    if (isReady) {
      return (
        <div className="w-screen bg-black relative p2p-svh">
          <iframe
            ref={iframeRef}
            src="game/index.html"
            className="w-full h-full border-0 block"
            allow="autoplay; fullscreen; gamepad; accelerometer; gyroscope"
            onLoad={handleGameLoaded}
          />
        </div>
      );
    }

    return (
      <div className="bg-black flex flex-col items-center justify-center text-center p-4 text-white p2p-svh" style={{ width: "100vw" }}>
        <div className="text-4xl mb-4 animate-bounce">üéÆ</div>
        <h1 className="text-2xl font-bold mb-2">{msg}</h1>
        <p className="text-gray-500 text-sm">Do not close this tab</p>
      </div>
    );
  };

  // =========================
  // Router
  // =========================
  const App = () => {
    const [route, setRoute] = useState('host');
    const [hostId, setHostId] = useState('');

    useEffect(() => {
      const check = () => {
        const hash = window.location.hash;
        if (hash.includes('/play')) {
          const id = new URLSearchParams(hash.split('?')[1] || '').get('host');
          if (id) {
            setHostId(id);
            setRoute('play');
            return;
          }
        }
        setRoute('host');
      };
      check();
      window.addEventListener('hashchange', check);
      return () => window.removeEventListener('hashchange', check);
    }, []);

    return route === 'play' ? <TesterView hostId={hostId} /> : <HostView />;
  };

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
</script>
</body>
</html>
