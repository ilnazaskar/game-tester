<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C3 P2P Tester</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-gray-900 text-white overflow-hidden">
<div id="root"></div>

<script type="text/babel">
const { useState, useEffect, useRef } = React;
const createPeer = (id) => new Peer(id, { debug: 0 });

// --- HOST ---
const HostView = () => {
    const [peerId, setPeerId] = useState('');
    const [zipFile, setZipFile] = useState(null);
    const [status, setStatus] = useState('disconnected');
    const [statusMsg, setStatusMsg] = useState('Initializing...');
    const [remoteStream, setRemoteStream] = useState(null);
    const [isValidating, setIsValidating] = useState(false);

    const peerRef = useRef(null);
    const connRef = useRef(null);
    const videoRef = useRef(null);

    useEffect(() => {
        const id = Math.random().toString(36).substring(2, 10);
        const peer = createPeer(id);
        peerRef.current = peer;

        peer.on('open', (id) => {
            setPeerId(id);
            setStatusMsg('Ready. Waiting for ZIP...');
        });

        peer.on('connection', (conn) => {
            connRef.current = conn;
            setStatus('connected');
            setStatusMsg('Tester connected!');
            conn.on('open', () => {
                if (zipFile) sendFile(conn, zipFile);
                else setStatusMsg('Tester connected. Please upload ZIP.');
            });
            conn.on('close', () => {
                setStatus('disconnected');
                setStatusMsg('Tester disconnected.');
                setRemoteStream(null);
            });
        });

        peer.on('call', (call) => {
            call.answer();
            call.on('stream', (stream) => {
                setRemoteStream(stream);
                setStatus('playing');
                setStatusMsg('Receiving stream...');
            });
        });

        return () => peer.destroy();
    }, [zipFile]);

    useEffect(() => {
        if (videoRef.current && remoteStream) {
            videoRef.current.srcObject = remoteStream;
        }
    }, [remoteStream]);

    const handleFile = async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;

        setIsValidating(true);
        setZipFile(null); 

        try {
            const zip = await JSZip.loadAsync(file);
            const hasIndex = Object.keys(zip.files).some(p => p.toLowerCase().endsWith('index.html'));
            
            if (!hasIndex) {
                alert('Error: No index.html found in ZIP!');
                setIsValidating(false);
                return;
            }

            setZipFile(file);
            setStatusMsg('Build verified! Link is ready.');
            
            if (connRef.current && connRef.current.open) {
                sendFile(connRef.current, file);
            }
        } catch (err) {
            console.error(err);
            alert('Invalid ZIP file');
        }
        setIsValidating(false);
    };

    const sendFile = async (conn, file) => {
        setStatus('transferring');
        setStatusMsg(`Sending ${file.name}...`);
        
        conn.send({ type: 'meta', filename: file.name, size: file.size, mime: file.type });
        await new Promise(r => setTimeout(r, 500));
        
        const buffer = await file.arrayBuffer();
        conn.send(buffer);
        
        setStatus('playing');
        setStatusMsg('Sent. Waiting for stream...');
    };

    const link = peerId ? `${window.location.origin}${window.location.pathname}#/play?host=${peerId}` : '';

    return (
        <div className="h-screen flex flex-col p-6 w-full max-w-[95vw] mx-auto font-sans">
            <header className="mb-6 flex justify-between items-center">
                <div>
                    <h1 className="text-3xl font-bold text-blue-500 tracking-tight">C3 P2P Tester</h1>
                    <p className="text-gray-400 text-sm">GitHub Pages Edition</p>
                </div>
                <div className="text-right">
                     <div className={`text-sm font-mono px-3 py-1 rounded border ${status === 'connected' ? 'border-green-500 text-green-400' : 'border-gray-600 text-gray-500'}`}>
                        {statusMsg}
                     </div>
                </div>
            </header>

            <div className="bg-gray-800 p-6 rounded-xl border border-gray-700 mb-6 flex gap-6 shadow-lg">
                <div className="flex-1">
                    <label className={`
                        flex flex-col items-center justify-center w-full h-full p-4 border-2 border-dashed rounded-xl cursor-pointer transition-all
                        ${zipFile ? 'border-green-500/50 bg-green-900/10' : 'border-gray-600 hover:border-blue-500 hover:bg-gray-700/50'}
                    `}>
                        <input type="file" onChange={handleFile} className="hidden" accept=".zip" disabled={isValidating} />
                        <div className="text-3xl mb-2">
                            {isValidating ? '‚è≥' : (zipFile ? '‚úÖ' : 'üìÇ')}
                        </div>
                        <span className="text-sm font-medium text-gray-300">
                            {zipFile ? zipFile.name : "1. Upload Game ZIP"}
                        </span>
                    </label>
                </div>

                <div className={`flex-[2] transition-all duration-300 ${!zipFile ? 'opacity-30 pointer-events-none blur-[1px]' : 'opacity-100'}`}>
                    <label className="text-xs text-gray-500 uppercase font-bold tracking-wider mb-2 block">2. Share Link</label>
                    <div className="flex gap-2">
                        <input 
                            readOnly 
                            value={zipFile ? link : 'Upload file first...'} 
                            className="bg-black/50 border border-gray-600 text-gray-300 text-sm rounded-lg px-4 py-3 flex-1 font-mono focus:outline-none focus:border-blue-500"
                        />
                        <button 
                            onClick={() => navigator.clipboard.writeText(link)}
                            disabled={!zipFile}
                            className="bg-blue-600 hover:bg-blue-500 text-white px-6 rounded-lg font-bold transition-colors shadow-lg shadow-blue-900/20"
                        >
                            COPY
                        </button>
                    </div>
                </div>
            </div>

            <div className="flex-1 bg-black rounded-xl border border-gray-700 relative overflow-hidden flex items-center justify-center shadow-2xl">
                {remoteStream ? (
                    <div className="relative w-full h-full">
                        <video 
                            ref={videoRef} 
                            className="w-full h-full object-contain" 
                            autoPlay 
                            playsInline 
                            muted 
                        />
                        <div className="absolute top-4 right-4 bg-red-600 text-white text-xs font-bold px-3 py-1 rounded-full animate-pulse shadow-lg">
                            üî¥ LIVE STREAM
                        </div>
                    </div>
                ) : (
                    <div className="text-gray-500 flex flex-col items-center animate-pulse">
                        <div className="text-6xl mb-4 opacity-20">üì∫</div>
                        <p className="text-xl font-medium">Waiting for gameplay stream...</p>
                    </div>
                )}
            </div>
        </div>
    );
};

// --- TESTER ---
const TesterView = ({ hostId }) => {
    const [msg, setMsg] = useState('Connecting to host...');
    const [isReady, setIsReady] = useState(false);
    const [started, setStarted] = useState(false);
    const peerRef = useRef(null);

    useEffect(() => {
        const peer = createPeer();
        peerRef.current = peer;

        peer.on('open', () => {
            const conn = peer.connect(hostId);
            conn.on('open', () => setMsg('Connected! Waiting for game...'));
            
            conn.on('data', async (data) => {
                if (data && data.type === 'meta') {
                    setMsg(`Downloading ${data.filename}...`);
                } else {
                    setMsg('Processing game package...');
                    await processZip(data);
                }
            });

            conn.on('close', () => setMsg('Host disconnected'));
        });

        return () => peer.destroy();
    }, [hostId]);

    const processZip = async (data) => {
        try {
            const z = await JSZip.loadAsync(data);
            const files = [];
            let hasIdx = false;

            await Promise.all(Object.keys(z.files).map(async p => {
                if (z.files[p].dir) return;
                let b = await z.files[p].async('blob');
                
                if (p.toLowerCase().endsWith('index.html')) {
                    let txt = await b.text();
                    const patch = `<script>(function(){navigator.serviceWorker.register=()=>new Promise(()=>{});const o=HTMLCanvasElement.prototype.getContext;HTMLCanvasElement.prototype.getContext=function(t,p){p=p||{};if(t==='webgl'||t==='webgl2'){p.preserveDrawingBuffer=true;p.alpha=false;p.stencil=true;}return o.call(this,t,p);}})()<\/script>`;
                    txt = txt.replace(/<head>/i, '<head>' + patch);
                    b = new Blob([txt], {type:'text/html'});
                    hasIdx = true;
                }

                let t = 'application/octet-stream';
                if(p.endsWith('.html')) t='text/html'; else if(p.endsWith('.js')) t='text/javascript';
                else if(p.endsWith('.css')) t='text/css'; else if(p.endsWith('.json')) t='application/json';
                else if(p.endsWith('.png')) t='image/png'; else if(p.endsWith('.wasm')) t='application/wasm';
                
                files.push({ path: p, blob: new Blob([b], {type: t}) });
            }));
            
            if (!hasIdx) return setMsg('Error: No index.html');

            // –ò–ó–ú–ï–ù–ï–ù–ò–ï: –£–±—Ä–∞–ª–∏ {scope: '/'}
            const reg = await navigator.serviceWorker.register('./worker.js');
            await reg.update();
            
            const wait = () => navigator.serviceWorker.controller ? Promise.resolve() : new Promise(r => navigator.serviceWorker.addEventListener('controllerchange', r, {once:true}));
            await wait();

            navigator.serviceWorker.addEventListener('message', e => {
                if (e.data?.type === 'CACHE_COMPLETE') {
                    setIsReady(true);
                }
            }, {once:true});
            
            navigator.serviceWorker.controller.postMessage({ type: 'CACHE_FILES', files });

        } catch(e) { console.error(e); setMsg('Error processing files'); }
    };

    const startGame = async () => {
        try {
            const s = await navigator.mediaDevices.getDisplayMedia({ 
                video: { frameRate: 60 }, 
                audio: true 
            });
            peerRef.current.call(hostId, s);
            setStarted(true);
        } catch { 
            alert('To play, you must share the screen.'); 
        }
    };

    if (isReady) {
        return (
            <div className="w-screen h-screen bg-black relative group">
                {started ? (
                    // –ò–ó–ú–ï–ù–ï–ù–ò–ï: –£–±—Ä–∞–ª–∏ —Å–ª—ç—à –≤ –Ω–∞—á–∞–ª–µ –ø—É—Ç–∏ src="game/index.html"
                    <iframe src="game/index.html" className="w-full h-full border-0" allow="autoplay; fullscreen; gamepad" />
                ) : (
                    <button onClick={startGame} className="absolute inset-0 w-full h-full bg-gray-900 flex flex-col items-center justify-center hover:bg-gray-800 transition cursor-pointer">
                        <div className="text-8xl mb-6 animate-pulse">‚ñ∂Ô∏è</div>
                        <div className="text-4xl font-bold text-white mb-2">CLICK TO START GAME</div>
                        <div className="text-gray-400 text-lg">
                            Select <span className="text-white font-bold">"This Tab"</span> & Allow Audio
                        </div>
                    </button>
                )}
            </div>
        );
    }

    return (
        <div className="min-h-screen bg-black flex flex-col items-center justify-center text-center p-4 text-white">
            <div className="text-6xl mb-6 animate-bounce">üéÆ</div>
            <h1 className="text-2xl font-bold mb-2 text-blue-400">{msg}</h1>
            <p className="text-gray-500 text-sm">Do not close this tab</p>
        </div>
    );
};

const App = () => {
    const [h, setH] = useState(null);
    useEffect(() => {
        const c = () => {
            const p = new URLSearchParams(window.location.hash.split('?')[1]);
            setH(window.location.hash.includes('/play') ? p.get('host') : null);
        };
        c(); window.addEventListener('hashchange', c);
        return () => window.removeEventListener('hashchange', c);
    }, []);
    return h ? <TesterView hostId={h} /> : <HostView />;
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
</script>
</body>
</html>
